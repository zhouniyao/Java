package niming.parser;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Calendar;

import min3d.parser.ParseObjectData;
import min3d.vos.Number3d;
import min3d.vos.Uv;
import android.content.res.Resources;
import android.util.Log;

public class ParseObj extends Parser {
	
	private static final String TAG = "Obj Load...@author nimig";
	private final String OBJECT = "o";
	private final String MATERIAL_LIB = "mtllib";
	private final String USE_MATERIAL = "usemtl";
	private final String NEW_MATERIAL = "newmtl";
	private final String DIFFUSE_COLOR = "Kd";
	private final String DIFFUSE_TEX_MAP = "map_Kd";
	
	//计数
	private int faces = 0;
	private int normalsNum = 0;
	private int UVCoords = 0;
	private int verticesNum = 0;
	//构造函数
	public ParseObj(Resources resources, String resourceID) {
		this.resourceID = resourceID;
		this.resources = resources;
		
	}
	public void parser(){
		long startTime = Calendar.getInstance().getTimeInMillis();
		//导入文件
		InputStream fileIn = resources.openRawResource(resources.getIdentifier(
				resourceID, null, null));
		BufferedReader buffer = new BufferedReader(
				new InputStreamReader(fileIn));
		String line;

		Log.d(TAG, "Start parsing object " + resourceID);
		Log.d(TAG, "Start time " + startTime);
		
		//
		try {
			while((line = buffer.readLine()) != null){//读取一行
				if (line.startsWith("v"))
		        {
		            verticesNum++;
		            processVLine(line);
		        }else if (line.startsWith("f"))
		        {
					faces++;
		            processFLine(line);
		        } else if (line.startsWith("vn"))//法向量
		        {
		            normalsNum++;
		            processVNLine(line);
		        } else if (line.startsWith("vt"))//纹理坐标
		        {
		            UVCoords++;
		            processVTLine(line);
		        } 
			}
		} catch (Exception e) {
		}
	}
	/**
	 * 处理纹理行
	 */
	private void processVTLine(String line) {
		String[] tokens = line.split("[ ]+");
		Uv uv = new Uv();
		uv.u = Float.parseFloat(tokens[0]);
		uv.v = Float.parseFloat(tokens[1]);
		
		texCoords.add(uv);
	}
	/**
	 * 处理法向量行
	 */
	private void processVNLine(String line) {
		String[] tokens = line.split("[ ]+");
//		int c = tokens.length;
		Number3d vertex = new Number3d();
		vertex.x = Float.parseFloat(tokens[0]);
		vertex.y = Float.parseFloat(tokens[1]);
		vertex.z = Float.parseFloat(tokens[2]);
//		vertex.x = Float.valueOf(tokens[0]);
//		vertex.y = Float.valueOf(tokens[1]);
//		vertex.z = Float.valueOf(tokens[2]);
		
		normals.add(vertex);
	}
	/**
	 * 处理面行
	 */
	private void processFLine(String line) {
		String[] tokens = line.split("[ ]+");
		int c = tokens.length;

		if (tokens[1].matches("[0-9]+"))
		{
			caseFEqOne(tokens, c);
		}
		if (tokens[1].matches("[0-9]+/[0-9]+"))
		{
			caseFEqTwo(tokens, c);
		}
		if (tokens[1].matches("[0-9]+//[0-9]+"))
		{
			caseFEqOneAndThree(tokens, c);
		}
		if (tokens[1].matches("[0-9]+/[0-9]+/[0-9]+"))
		{
			caseFEqThree(tokens, c);
		}
	}
	/**
	 * 面处理（部分）
	 */
	private void caseFEqThree(String[] tokens, int c) {
		// TODO Auto-generated method stub
		
	}
	private void caseFEqOneAndThree(String[] tokens, int c) {
		// TODO Auto-generated method stub
		
	}
	private void caseFEqTwo(String[] tokens, int c) {
		Face f = new Face();
		for (int i = 1; i < c; i++)
		{
//			Short s = Short.valueOf(tokens[i].split("/")[0]);
//			s--;
//			_vPointer.add(s);
//
//			s = Short.valueOf(tokens[i].split("/")[1]);
//			s--;
//			_vtPointer.add(s);
			f.a = Short.parseShort(tokens[i].split("/")[0]);
		}
		faces.add(f);
	}
	private void caseFEqOne(String[] tokens, int c) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * 处理顶点行
	 */
	private void processVLine(String line) {
		String[] tokens = line.split("[ ]+");
//		int c = tokens.length;
		Number3d vertex = new Number3d();
		vertex.x = Float.parseFloat(tokens[0]);
		vertex.y = Float.parseFloat(tokens[1]);
		vertex.z = Float.parseFloat(tokens[2]);
//		vertex.x = Float.valueOf(tokens[0]);
//		vertex.y = Float.valueOf(tokens[1]);
//		vertex.z = Float.valueOf(tokens[2]);
		
		vertices.add(vertex);
	}
}
