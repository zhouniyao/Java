package niming.core;

import static android.opengl.GLES20.GL_FLOAT;
import static android.opengl.GLES20.GL_TEXTURE0;
import static android.opengl.GLES20.GL_TEXTURE_2D;
import static android.opengl.GLES20.GL_TRIANGLES;
import static android.opengl.GLES20.GL_TRIANGLE_STRIP;
import static android.opengl.GLES20.glActiveTexture;
import static android.opengl.GLES20.glBindTexture;
import static android.opengl.GLES20.glClearColor;
import static android.opengl.GLES20.glEnableVertexAttribArray;
import static android.opengl.GLES20.glGetAttribLocation;
import static android.opengl.GLES20.glGetUniformLocation;
import static android.opengl.GLES20.glUniform1i;
import static android.opengl.GLES20.glUniformMatrix4fv;
import static android.opengl.GLES20.glUseProgram;
import static android.opengl.GLES20.glVertexAttribPointer;
import static android.opengl.GLES20.glViewport;
import static android.opengl.Matrix.rotateM;
import static android.opengl.Matrix.scaleM;
import static android.opengl.Matrix.setIdentityM;
import static android.opengl.Matrix.translateM;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import niming.parser.ObjParser;
import niming.parser.ParseObjectData;
import niming.util.Constant;
import niming.util.ShaderHelper;
import niming.util.TextResourceReader;
import niming.util.TextureHelper;
import niming.util.Utils;

import com.bn.Sample6_2.Ball;
import com.bn.Sample6_2.MatrixState;
import com.bn.Sample6_2.MySurfaceView;
import com.example.vrndk01.R;
import com.geometric.BezierSurface;
import com.geometric.Number3d;
import com.geometric.Uv;
import com.geometric.BezierSurface2;

import android.R.integer;
import android.content.Context;
import android.opengl.GLES20;
import android.opengl.GLSurfaceView;
import android.opengl.Matrix;
import android.os.Handler;
import android.os.SystemClock;
import android.util.Log;
import android.view.MotionEvent;
import android.widget.Toast;
/**
 * 专为Beizer曲面打造的渲染器
 *
 */
public class BezierGLSurfaceView extends GLSurfaceView{
	private final float TOUCH_SCALE_FACTOR = 180.0f/320;//角度缩放比例
    public SceneRenderer mRenderer;//场景渲染器	   
	private float mPreviousY;//上次的触控位置Y坐标
    private float mPreviousX;//上次的触控位置X坐标
	public BezierGLSurfaceView(MyActivity activity, BezierSurface bezierResource) {
		super(activity);
        this.setEGLContextClientVersion(2); //设置使用OPENGL ES2.0
        mRenderer = new SceneRenderer(activity, bezierResource);	//创建场景渲染器
        setRenderer(mRenderer);				//设置渲染器		        
        setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);//设置渲染模式为主动渲染   
	}
	/**
	 * 得到内置渲染对象
	 * @return
	 */
	public SceneRenderer getRenderer() {
		return mRenderer;
	}
	//触摸事件回调方法
    @Override 
    public boolean onTouchEvent(MotionEvent e) {
    	if(e != null){
			float y = e.getY();
	        float x = e.getX();
	        switch (e.getAction()) {
	        case MotionEvent.ACTION_DOWN:
	        	mPreviousX = x;
	        	mPreviousY = y;
	        	break;
	        case MotionEvent.ACTION_MOVE:
	            float dy = y - mPreviousY;//计算触控笔Y位移
	            float dx = x - mPreviousX;//计算触控笔X位移 
	            if(mRenderer.isTouch){
	            	mRenderer.yAngle += dx * TOUCH_SCALE_FACTOR;//设置填充椭圆绕y轴旋转的角度
	            	mRenderer.xAngle += dy * TOUCH_SCALE_FACTOR;//设置填充椭圆绕x轴旋转的角度
	            }
	            if(mRenderer.isRotate){
	            	mRenderer.handleTouchDrag(dx, dy);////给3D物体加速度，旋转起来
	            }
	        }
	        mPreviousY = y;//记录触控笔位置
	        mPreviousX = x;//记录触控笔位置
			return true;
		}else {
			return false;
		}
    }
    /**
     * 按照顶点数组绘制，即DrawArrays()
     * 着色器程序为：simple_vertex_shader.glsl
     * u_Color着色器变量不可用
     * 设置触控图形
     * 设置缩放比例
     * 设置平移
     * 设置旋转 
     */
	public class SceneRenderer implements GLSurfaceView.Renderer 
    {
		private final Context context;
		private int vertiseNum;
		/*定义各类变换矩阵*/
		private float[] modelMatrix = new float[16];
		private float[] viewMatrix = new float[16];
		private float[] projectionMatrix = new float[16];
	    private float[] MVMatrix = new float[16];//矩阵连乘的中间结果
	    private float[] MVPMatrix = new float[16];//最终的矩阵
	    /*顶点数据准备*/
	    /* Store our model data in a float buffer. */
	    private FloatBuffer objPositions;
	    private FloatBuffer objNormalsss;
	    private FloatBuffer objTextureCoodinates;
	    /*openGL绑定的着色器程序ID*/
	    private int program;
	    /*定义常量区*/
	    private static final int BYTES_PER_FLOAT = 4;
		private static final int POSITION_COMPONENT_COUNT = 2;
		/*private static final int POSITION_COMPONENT_COUNT = 4;*/
		private static final int COLOR_COMPONENT_COUNT = 3;
	    private static final String A_POSITION = "a_Position";
	    private static final String A_COLOR = "a_Color";
	    private static final String A_TEXCOORD = "a_TexCoordinate";
	    private static final String U_MVPMATRIX = "u_MVPMatrix";
	    
	 
	    
	    /*管线装配时，各着色器变量在OpenGL内的Location*/
	    private int aPositionLocation;
	    private int aColorLocation;
	    private int aTextureCoordLocation;
	    private int uTextureUnitLoaction;
	    private int uMVPMatrixLocation;
	    
	    /*整个屏幕的宽高px值*/
	    private int screenWidth;
	    private int screenHeight;
	    float aspectRatio;//屏幕宽高比，宽/高 > 1
	    /* 设置触控图形*/
	    float touchX;
	    float touchY;
	    /* 设置缩放比例*/
	    private float scaleX = 1f;
	    private float scaleY = 1f;
	    private float scaleZ = 1f;
	    /* 设置平移*/
	    private float translateX = 0f;
	    private float translateY = 0f;
	    private float translateZ = 0f;
	    /* 设置旋转 */
	    private float rotateX = 0f;
	    private float rotateY = 0f;//若要物体旋转，旋转矩阵必须有个参数不为0
	    private float rotateZ = 0f;
	    private float speed = 0f; //旋转速度
	    
		public float yAngle = 0;// 绕y轴旋转的角度
		public float xAngle = 0;// 绕x轴旋转的角度
		public float zAngle = 0;// 绕z轴旋转的角度
	    
	    public boolean isRotate = false;//旋转起来
	    public boolean isTouch = false;//跟随触碰任意转
		float rotate = 0;//物体旋转的位置，如果有速度，每次都增加速度
	    /*保存触屏位置*/
	    float oldX = 0f;
	    float oldY = 0f;
	    /*纹理ID*/
	    private int texResourceId;
	//  int texture1;
	    int texture2;
	    /**构造器中的3个初始化量*/
	    private ObjParser obj;
	    private ParseObjectData car;
	    final Handler hd;
	    int TYPE = Constant.LINES; //以什么形式绘制图形，默认是三角面绘制
	    
	    final BezierSurface2 bezier;
	    /**
	     * 设置图形旋转
	     */
	    public void setRotate(float speed, float x, float y, float z) {
	    	this.isRotate = true;
			this.rotateX  = x;
			this.rotateY  = y;
			this.rotateZ  = z;
			this.speed = speed;
		}
	    /**
	     * 设置图形整体平移
	     * @param x y z
	     */
	    public void setTranslate(float x, float y, float z) {
	        translateX += x;
	        translateY += y;
	        translateZ += z;
		}
	    /**
	     * 设置图形的缩放比例
	     * @param x、y、z的缩放比例
	     */
	    public void setScale(float x, float y, float z) {
	    	if(x <= 0 || y <= 0 || z <= 0){
	    		Toast.makeText(context, "输入的比例数据有误，请重新输入",Toast.LENGTH_SHORT).show();
	    		return;
	    	}
	        scaleX = x;
	        scaleY = y;
	        scaleZ = z;
		}
	    
	    /**
	     * 设置图形输出类型
	     * @param type
	     */
	    public void setTYPE(int type) {
	    	switch (type) {
			case 0:
				TYPE = Constant.POINTS;
				break;
			case 1:
				TYPE = Constant.LINES;
				break;
			case 2:
				TYPE = Constant.FACES;
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			default:
				Toast.makeText(context, "输出类型错误，请选择以下类型：Constant.POINTS、Constant.LINES、FACES",Toast.LENGTH_SHORT).show();
				return;
			}
		}
		/**
		 * 渲染构造器
		 * @param 当前活动的activity
		 * @param OBJ文件objResource
		 * @param 纹理resourceID
		 */
	    public SceneRenderer(MyActivity activity, BezierSurface bezierResource) {
	    	this.context = activity;
			this.hd = activity.hd;
			bezier = new BezierSurface2(context);
		}

        public void onSurfaceChanged(GL10 gl, int width, int height) {
            //设置视窗大小及位置 
        	GLES20.glViewport(0, 0, width, height); 
        	//计算GLSurfaceView的宽高比
            Constant.ratio = (float) width / height;
			// 调用此方法计算产生透视投影矩阵
            MatrixState.setProjectFrustum(-Constant.ratio, Constant.ratio, -1, 1, 20, 100);
			// 调用此方法产生摄像机9参数位置矩阵
			MatrixState.setCamera(0, 0f, 30, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
            
            //初始化变换矩阵
            MatrixState.setInitStack();
        }

        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            //设置屏幕背景色RGBA
            GLES20.glClearColor(0f,0f,0f, 1.0f);  
            //创建球对象
            ball=new Ball(MySurfaceView.this);
            //打开深度检测
            GLES20.glEnable(GLES20.GL_DEPTH_TEST);
            //打开背面剪裁   
            GLES20.glEnable(GLES20.GL_CULL_FACE);
        }
		public void onDrawFrame(GL10 gl) 
		{ 
			//清除深度缓冲与颜色缓冲
			GLES20.glClear( GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
		}  
	    
    }//End Renderer
}
