package niming.VR2;

import static android.opengl.GLES20.*;
import static android.opengl.Matrix.*;


import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import com.example.vrndk01.R;
import com.geometric.BezierSurface2;

import android.content.Context;
import android.opengl.GLSurfaceView;
import android.opengl.GLSurfaceView.Renderer;
import android.os.Bundle;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import niming.core.MyActivity;
/**
 * 根据触碰任意旋+可以加速度旋转   汽车 【失败】
 *
 */
public class BezierSurfaceDemo extends MyActivity {
	private float mPreviousY;//上次的触控位置Y坐标
	private float mPreviousX;//上次的触控位置X坐标
	private final float TOUCH_SCALE_FACTOR = 180.0f/320;//角度缩放比例
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		mGLSurfaceView = new GLSurfaceView(this);
        // Request an OpenGL ES 2.0 compatible context.
       mGLSurfaceView.setEGLContextClientVersion(2);            
        
        // Assign our renderer.
//        glSurfaceView.setRenderer(new AirHockeyRenderer(this));
        mGLSurfaceView.setRenderer(new proRenderer(this));
		// 切换到主界面
		setContentView(R.layout.activity_seekbar);	
		LinearLayout ll = (LinearLayout) findViewById(R.id.main_liner);
		ll.addView(mGLSurfaceView);
        //普通拖拉条被拉动的处理代码
        SeekBar sb=(SeekBar)this.findViewById(R.id.SeekBar01);
        sb.setOnSeekBarChangeListener(
            new SeekBar.OnSeekBarChangeListener()
            {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress,
						boolean fromUser) {
//					mGLSurfaceView.setLightOffset((seekBar.getMax()/2.0f-progress)/(seekBar.getMax()/2.0f)*-4);
				}
				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {	}
				@Override
				public void onStopTrackingTouch(SeekBar seekBar) { }            	
            }
        );

	}
}
class proRenderer implements Renderer{
	BezierSurface2 bezier;
	
	private static final int POSITION_COMPONENT_COUNT = 2;
//	private static final int POSITION_COMPONENT_COUNT = 4;
	private static final int BYTES_PER_FLOAT = 4;
//	private final FloatBuffer vertexData;
	private final Context context;
	private int program;
	//	获得一个uniform的位置
	private static final String U_COLOR = "u_Color";
	private int uColorLocation;
	//获取属性的位置
	private static final String A_POSITION = "a_Position";
	private int aPositionLocation;
	
	private static final String A_COLOR = "a_Color";
	private static final int COLOR_COMPONENT_COUNT = 3;
	private static final int STRIDE = (POSITION_COMPONENT_COUNT + COLOR_COMPONENT_COUNT) * BYTES_PER_FLOAT;
	private int aColorLocation;
	
	/*第五章*/
	private static final String U_MATRIX = "u_Matrix";
	private final float[] projectionMatrix = new float[16];
	private int uMatrixLocation;
	
	/*第六章*/
	//投影矩阵、平移矩阵、旋转矩阵
	private final float[] modelMatrix = new float[16];

	private int screenWidth;

	private int screenHeight;

	private float aspectRatio;
	
	
	/*
	 * 第三章内容，搭建游戏框架
	 * 创建一个浮点数数组，这些浮点数表示组成空气曲棍球桌子的顶点的位置；
	 * 本地内存中创建一个缓冲区，称为vertexData，并把这些位置复制到这个缓冲区内。
	 * 在我们告诉OpenGL从这个缓冲区中读取数据前，需要确保它会从开头处开始读取数据，而不是中间或尾。
	 * 每个缓冲区都有一个内部指针，可以通过调用position(int)移动它，
	 * 然后，我们调用glVertexAttribPointer()告诉OpenGL，它可以在缓冲区vertexData中找到a_Position对应的数据。
	 */
	public proRenderer(Context context){
		this.context = context;
		bezier = new BezierSurface2(context);
	}
	
	
	@Override
	/**
	 * 把着色器源代码从文件中读出来
	 */
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {
	   /*
		// Set the background clear color to red. The first component is red,
		// the second is green, the third is blue, and the last component is
		// alpha, which we don't use in this lesson.
		glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
       */
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	}

	
	@Override
	public void onSurfaceChanged(GL10 gl, int width, int height) {
		glViewport(0, 0, width, height);
//		Log.i(TAG, "$宽3："+ width + "    " + "$高3：" + height);
		screenWidth = width;
		screenHeight= height;
		/**screenWidth/2 < screenHeight */ 
		//屏幕高-宽比(两个半屏),即aspecRatio > 1
		aspectRatio = (width/2) > height ?
				(float)(width/2)/(float)height : (float)height/(float)(width/2);
	}
	
	@Override
	/**
	 * 几乎所有的display()完成类似操作
	 * 1)调用glClear()来清除窗口内容；
	 * 2)调用OpenGL命令来渲染对象；
	 * 3)将最终图像输出到屏幕。
	 */
	public void onDrawFrame(GL10 gl) {
		// Clear the rendering surface.
		glViewport(0, 0, 500, 800);
		glClear(GL_COLOR_BUFFER_BIT);
		/*第五章*/
		glUniformMatrix4fv(uMatrixLocation, 1, false, projectionMatrix, 0);//把projectionMatrix与着色器uMatrixLocation关联
		/*第四章*/
		/*桌子边缘*/
		glDrawArrays(GL_TRIANGLES, 0, 6);//绘制桌子，
										//参数说明：第一个参数，绘制为三角形；第二个参数，从顶点数组的开头处读顶点；第三个参数是读入的顶点数，6表示绘制2个三角形。
		/*绘制桌面*/
		glDrawArrays(GL_TRIANGLE_FAN, 6, 6);//围绕中心点扇形绘制三角形
		/*绘制分割线*/
		glDrawArrays(GL_LINES, 12, 2);
		
		/*绘制木槌*/
		glDrawArrays(GL_POINTS, 14, 1);
		//Draw the second mallet red;
		glDrawArrays(GL_POINTS, 15, 1);
		
		
		
		
		
		glViewport(500, 0, 500, 800);
		/*桌子边缘*/
		glDrawArrays(GL_TRIANGLES, 0, 6);//绘制桌子，
										//参数说明：第一个参数，绘制为三角形；第二个参数，从顶点数组的开头处读顶点；第三个参数是读入的顶点数，6表示绘制2个三角形。
		/*绘制桌面*/
		glDrawArrays(GL_TRIANGLE_FAN, 6, 6);//围绕中心点扇形绘制三角形
		/*绘制分割线*/
		glDrawArrays(GL_LINES, 12, 2);
		
		/*绘制木槌*/
		glDrawArrays(GL_POINTS, 14, 1);
		//Draw the second mallet red;
		glDrawArrays(GL_POINTS, 15, 1);
		
		//Draw the ice hockey
//		glDrawArrays(GL_POINTS, 16, 1);
		
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);		
	}

	
}